---
title: "Analysis of single-cell RNA-seq data using fastTopics: an illustration"
author: Peter Carbonetto
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fastTopics single-cell RNA-seq demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Here we illustrate the use of **fastTopics** to infer structure in a
population of cells from single-cell RNA-seq data. A basic analysis
consists of these five steps:

1. Load and prepare the count data.

2. Fit a Poisson non-negative matrix factorization (NMF) to the UMI
   count data.

3. Recover the multinomial topic model from the Poisson NMF model fit.

4. Analyze structure in the mixture proportions matrix.

5. Annotate selected clusters and topics by performing a differential
   expression analysis.

Here we walk through these steps of the analysis, and show how
fastTopics can be used to quickly implement each of these steps.

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

Beyond fastTopics, we use the Matrix package to load the sparse counts
matrix, and we use the ggplot2 and cowplot packages to create plots.

```{r load-pkgs, message=FALSE, warning=FALSE}
library(Matrix)
library(fastTopics)
library(ggplot2)
library(cowplot)
```

We set the seed so that the results can be reproduced.

```{r set-seed}
set.seed(1)
```

Load and prepare data
---------------------

Load the single-cell RNA-seq data. This data set combines reference
transcriptome profiles generated from 10 different bead-enriched
subpopulations of PBMCs (Donor A) as described in
[Zheng *et al* (2017)][zheng-2017]. The UMI counts are stored as an $n
\times m$ sparse matrix, where $n$ is the number of cells and $m$ is
the number of genes.

```{r load-data}
data(pbmc_4k)
samples <- pbmc_4k$samples
genes   <- pbmc_4k$genes
counts  <- pbmc_4k$counts
dim(counts)
```

No normalization or transformation of the UMI counts is needed. The
only pre-processing step we take is removing genes that are not
expressed in any of the cells (more generally, you should remove
columns in the counts matrix that do not vary).

```{r filter-genes}
j      <- which(colSums(counts > 0) >= 1)
genes  <- genes[j,]
counts <- counts[,j]
dim(counts)
```

The data are indeed sparse---most of the counts are zero:

```{r nonzeros}
mean(counts > 0)
```

Fit Poisson NMF model
---------------------

By exploiting the relationship between the multinomial topic model and
non-negative matrix factorization (we have a vignette elaborating on
this relationship), we leverage fast NMF optimization algorithms to
fit the multinomial topic model. This can take several minutes to run,
so we have saved the output of the `fit_poisson_nmf` code:

```{r load-fit}
fit <- pbmc_4k$fit
```

If you would like to see the Poisson NMF model fitting in action, try
running this next code chunk:

```{r fit-poisson-nm, eval=FALSE}
fit0 <- fit_poisson_nmf(counts,k = 6,numiter = 100,method = "em",
                        control = list(numiter = 4,nc = 2))
fit  <- fit_poisson_nmf(counts,fit0 = fit0,numiter = 100,method = "scd",
                        control = list(extrapolate = TRUE,numiter = 4,nc = 2))
```

(This is the code that was used to generate the stored result.) Note
that you may want to change `control$nc`, which controls the number of
threads in the TBB multithreaded computations, according to the number
of processors available on your computer.

Judging by this plot showing the change in the log-likelihood over
time, the iterates get very close to a solution---that is, they arrive
at a local maximum of the likelihood---after about 150 iterations.

```{r plot-loglik, fig.height=2, fig.width=3.5}
plot_progress_poisson_nmf(fit,x = "iter",add.point.every = 10,
                          colors = "black")
```

Here we briefly give some general guidance on the model fitting step,
and explain the model fitting settings used in the code above.

We have found that the EM algorithm initially makes rapid progress
toward a solution, but this convergence slows considerably as the
iterates approach the solution. Therefore, we have found it helpful to
first perform EM updates, then refine the fit using SCD updates. In
our experience, this refinement step works best using extrapolated SCD
updates.

For larger data sets, more than 200 updates may be needed to obtain a
good fit.

Recover multinomial topic model
-------------------------------

Once we have fit a Poisson NMF model, the multinomial topic model is
easly recovered by a reparameterization:

```{r poisson2multinom}
fit_multinom <- poisson2multinom(fit)
```

Identify clusters
-----------------

```{r pca-plot-1}
set.seed(1)
pca <- prcomp(fit_multinom$L)
ans <- kmeans(pca$x,centers = 6,iter.max = 100)
clusters <- ans$cluster
clusters[clusters == 3] <- 1
clusters <- factor(clusters)
levels(clusters) <- c("T","CD14+","B","CD34+","NK")
cluster_colors <- c("gold","forestgreen","dodgerblue","darkmagenta","gray")
p1 <- pca_plot(fit_multinom,pcs = 1:2,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
p2 <- pca_plot(fit_multinom,pcs = 3:4,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
plot_grid(p1,p2)
```

Summarize substructure with a Structure plot
--------------------------------------------

*Add text here.*

```{r structure-plot-1, fig.width=5.5, fig.height=1.5, results="hide"}
topic_colors <- c("skyblue","forestgreen","darkmagenta","dodgerblue",
                  "gold","darkorange")
p3 <- structure_plot(fit_multinom,topics = 1:6,colors = topic_colors)
print(p3)
```

*Add more text here.*

```{r structure-plot-2, fig.width=5.5, fig.height=1.5, results="hide"}
p4 <- structure_plot(fit_multinom,topics = 1:6,colors = topic_colors,
                     grouping = clusters,gap = 20)
print(p4)
```

*Add even more text here*.

```{r pca-plot-1}
clusters <- as.character(clusters)
clusters[clusters == "T" & fit_multinom$L[,1] > 0.1] <- "CD8+"
clusters <- factor(clusters)
cluster_colors <- c("dodgerblue","forestgreen","darkmagenta","red",
                    "gray","gold")
p5 <- pca_plot(fit_multinom,pcs = 1:2,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
p6 <- pca_plot(fit_multinom,pcs = 3:4,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
plot_grid(p5,p6)
```

*Add further text here.*

```{r structure-plot-3, fig.width=5.5, fig.height=1.5, results="hide"}
p7 <- structure_plot(fit_multinom,topics = 1:6,colors = topic_colors,
                     grouping = clusters,gap = 20)
print(p7)
```

Annotate topics and clusters
----------------------------

Here is where we use `diff_count_analysis` to interpret selected
clusters and topics.

```{r volcano-plots, eval=FALSE}
ans <- diff_count_analysis(fit_multinom,counts)
volcano_plot(ans,k = 5,labels = genes$symbol)
```

TO DO: Demonstrate how to create interactive volcano plot.

Identify clusters
-----------------

Having obtained the multinomial topic model, we now analyze the
mixture proportions matrix, `fit_multinom$L`. We begin this analysis
by identifying clusters from the principal components (PCs) of the
mixture proportions. *Note that we could plot the loadings matrix from
the NMF instead, but explain why this is not recommended for
expression data.*

The next two plots show the projection of the cells onto the top 4 PCs:

```{r pca-1, fig.width=4.5, fig.height=2}
p1 <- pca_plot(fit_multinom,pcs = 1:2,fill = "none")
p2 <- pca_plot(fit_multinom,pcs = 3:4,fill = "none")
plot_grid(p1,p2)
```

In some areas of the the PCA plot, there are many---sometimes
hundreds---of cells squeezed into a very tight space. In such cases,
it can be more effective to plot the density of the cells in the PC
projection:

```{r pca-2, fig.width=5.75, fig.height=1.75}
p3 <- pca_hexbin_plot(fit_multinom,pcs = 1:2,bins = 24)
p4 <- pca_hexbin_plot(fit_multinom,pcs = 3:4,bins = 24)
plot_grid(p3,p4)
```

Based on these plots, we subdivide the cells into 6 clusters. (This
happens to be the same as $K$, the number of factors or topics, but in
general there may be more clusters than $K$, or fewer.)

```{r pca-3, fig.width=5.75, fig.height=2, message=FALSE}
n   <- nrow(counts)
pca <- prcomp(fit_multinom$L)$x
clusters <- rep("CD8+",n)
pc1 <- pca[,1]
pc2 <- pca[,2]
pc3 <- pca[,3]
pc4 <- pca[,4]
clusters[pc2 > 0] <- "T"
clusters[pc2 < -0.3] <- "NK"
clusters[pc2 > pc1 + 0.6] <- "B"
clusters[pc3 > 0.15] <- "CD34+"
clusters[pc4 < -0.6] <- "CD14+"
clusters <- factor(clusters)
cluster_colors <- c("dodgerblue",  # B-cells
                    "forestgreen", # CD14+
                    "darkmagenta", # CD34+ 
                    "red",         # CD8+
                    "skyblue",     # NK
                    "darkorange")  # T-cells
p5 <- pca_plot(fit_multinom,pcs = 1:2,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
p6 <- pca_plot(fit_multinom,pcs = 3:4,fill = clusters) +
  scale_fill_manual(values = cluster_colors)
plot_grid(p5,p6)
```

*Add text here.*

Structure plot
--------------

The structure plot summarizes the mixture proportions of the cells in
each of the 6 clusters:

```{r structure-plot-better, fig.width=5.75, fig.height=1.5, message=FALSE, results="hide"}
structure_plot(fit_multinom,grouping = clusters,topics = 1:6,
               colors = topic_colors,gap = 25)
```

*Add text here explaining how the Structure plot works.*

[zheng-2017]: https://doi.org/10.1038/ncomms14049
