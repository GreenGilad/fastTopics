---
title: Illustration of fastTopics applied to single-cell RNA-seq data
author: Peter Carbonetto
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fastTopics single-cell RNA-seq demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Here we illustrate the use of **fastTopics** to infer structure in a
population of cells from single-cell RNA-seq data. The analysis
consists of five steps:

1. Load and prepare the count data.

2. Fit a Poisson non-negative matrix factorization (NMF) to the UMI
   count data.

3. Recover the multinomial topic model from the Poisson NMF model fit.

4. Identify clusters from principal components (PCs) of the mixture
   proportions matrix.

5. Annotate selected clusters and topics by performing a differential
   expression analysis.

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

*Add text here.*

```{r load-pkgs, message=FALSE, warning=FALSE}
library(Matrix)
library(fastTopics)
library(ggplot2)
library(cowplot)
```

We set the seed so that the results can be reproduced.

```{r set-seed}
set.seed(1)
```

1. Load and prepare data
------------------------

Load the single-cell RNA-seq data. This data set combines reference
transcriptome profiles generated from 10 different bead-enriched
subpopulations of PBMCs (Donor A) as described in
[Zheng *et al* (2017)][zheng-2017]. The UMI counts are stored as an $n
\times m$ sparse matrix, where $n$ is the number of cells and $m$ is
the number of genes.

```{r load-data}
data(pbmc_4k)
samples <- pbmc_4k$samples
genes   <- pbmc_4k$genes
counts  <- pbmc_4k$counts
dim(counts)
```

No normalization or transformation of the UMI counts is needed. The
only processing step needed is to remove genes that are not expressed
in any of the cells (more generally, we should remove columns that do
not vary).

```{r filter-genes}
j      <- which(colSums(counts > 0) >= 1)
genes  <- genes[j,]
counts <- counts[,j]
dim(counts)
```

The data are indeed sparse---most of the counts are zero:

```{r nonzeros}
mean(counts > 0)
```

2. Fit Poisson NMF model
------------------------

By exploiting the relationship between the multinomial topic model and
non-negative matrix factorization---we have a vignette explaining this
relationship---we leverage fast NMF optimization algorithms to fit the
multinomial topic model. This can take several minutes to run, so we
have saved the output of the `fit_poisson_nmf` code:

```{r load-fit}
fit <- pbmc_4k$fit
```

Otherwise, if you would like to see the Poisson NMF model fitting in
action, try running the code in this next code chunk. (This was the
exact code that was used to generate the stored result.) Note that you
may want to change `control$nc`, which controls the number of threads
in the TBB multithreaded computations, according to the number of
processors available on your computer.

```{r fit-poisson-nm, eval=FALSE}
fit0 <- fit_poisson_nmf(counts,k = 6,numiter = 100,method = "em",
                        control = list(numiter = 4,nc = 2))
fit  <- fit_poisson_nmf(counts,fit0 = fit0,numiter = 100,method = "scd",
                        control = list(extrapolate = TRUE,numiter = 4,nc = 2))
```

Judging by this plot showing the change in the log-likelihood over
time, the iterates get very close to a solution---that is, a
local maximum of the likelihood---after about 150 iterations.

```{r plot-loglik, fig.height=2.5, fig.width=3.5}
plot_progress_poisson_nmf(fit,x = "iter",add.point.every = 10,
                          colors = "black")
```

Here we briefly give some guidance on the model fitting, and explain
the optimization settings used in the code above.

We have found that the EM algorithm initially makes rapid progress
toward a solution, but this convergence slows considerably as the
iterates approach the solution. Therefore, we have found it helpful to
first perform EM updates, then refine the fit using SCD updates. In
our experience, this refinement step works best using the SCD updates
combined with the "extrapolation" scheme.

For larger data sets, more than 200 updates may be needed to arrive at
a good solution.

3. Recover multinomial topic model
----------------------------------

Recover the multinomial topic model.

```{r poisson2multinom}
fit_multinom <- poisson2multinom(fit)
```

Identify clusters from PCs
--------------------------

Here we define clusters by manually inspecting the principal
components (PCs) of the mixture proportions. (Other approaches may be
applied to the task of identifying clusters.)

These two plots show the projection of the cells onto the top 4 PCs:

```{r pca-1, fig.width=6, fig.height=2}
plot_grid(pca_plot(fit_multinom,pcs = 1:2,fill = "none"),
          pca_plot(fit_multinom,pcs = 3:4,fill = "none"))
```

In some areas of the the PCA plot, there are many---sometimes
hundreds---of cells squeezed into a very tight space, so it can
helpful to instead visualize the *density* of the cells in the PC
projection:

```{r pca-2, fig.width=6, fig.height=2}
plot_grid(pca_hexbin_plot(fit_multinom,pcs = 1:2,bins = 24),
          pca_hexbin_plot(fit_multinom,pcs = 3:4,bins = 24))
```

TO DO: Define clusters from PCA plots.

Structure plot
--------------

The structure plot summarizes the mixture proportions of the cells in
each of the 6 clusters:

TO DO: Add Structure plot here.

TO DO: Remove "cluster" column from `pbmc_4k` data.

Annotate topics and clusters
----------------------------

Here is where we use `diff_count_analysis` to interpret selected
clusters and topics.

[Use "topic" and "factor" interchangeably here.]

[zheng-2017]: https://doi.org/10.1038/ncomms14049
