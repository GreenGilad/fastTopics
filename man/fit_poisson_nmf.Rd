% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_poisson_nmf.R
\name{fit_poisson_nmf}
\alias{fit_poisson_nmf}
\alias{init_poisson_nmf}
\alias{fit_poisson_nmf_control_default}
\title{Multiplicative and EM Update Rules for Poisson Non-negative
  Matrix Factorization}
\usage{
fit_poisson_nmf(
  X,
  k,
  fit,
  numiter = 100,
  method = c("altsqp", "scd", "ccd", "em", "mu"),
  control = list(),
  verbose = TRUE
)

init_poisson_nmf(X, F, L, k)

fit_poisson_nmf_control_default()
}
\arguments{
\item{X}{The n x m matrix of counts; all entries of X should be
non-negative. Note that sparse matrices are not accommodated
in this implementation; \code{is.matrix(X)} must give \code{TRUE}.}

\item{k}{This argument specifies the rank for a random
initialization of the factors and loadings. (The matrix entries are
initialized uniformly at random.) This should only be specified if
the initial estimates (\code{fit} or \code{F, L}) aren't already
provided.}

\item{numiter}{The number of multiplicative updates to run.}

\item{method}{When \code{method = "em"}, the EM updates will be
performed; when \code{method = "mu"}, the multiplicative updates
will be performed. The multiplicative updates are only implemented
for dense count matrices; if \code{method = "mu"} and \code{X} is a
sparse matrix, and error will be generated.}

\item{verbose}{When \code{verbose = TRUE}, information about the
algorithm's progress is printed to the console at each iteration.}

\item{F}{An optional argument giving is the initial estimate of the
factors (also sometimes called the "basis vectors"). It should be
an m x k matrix, where m is the number of columns in the counts
matrix X, and k > 1 is the rank of the matrix factorization, or,
equivalently, the number of topics. All entries of F should be
non-negative. If not provided, input argument \code{k} should be
given.}

\item{L}{An optional argument giving the initial estimate of the
loadings (also sometimes called the "activations"). It should an n
x k matrix, where n is the number of rows in the counts matrix X,
and k > 1 is the rank of the matrix factorization. All entries of L
should be non-negative. If not provided, input argument \code{k}
should be given.}

\item{minval}{A small positive constant used to safeguard the
multiplicative updates. The multiplicative updates are implemented
as \code{F <- pmax(F1,minval)} and \code{L <- pmax(L1,minval)},
where \code{F1} and \code{L1} are the factors and loadings matrices
obtained by applying a single multiplicative update rule. Setting
\code{minval = 0} is allowed, but the multiplicative updates are
not guaranteed to converge to a stationary point without this
safeguard, and a warning will be given in this case.}

\item{e}{A small, non-negative number added to the terms inside the
logarithms to avoid computing logarithms of zero. This prevents
numerical problems at the cost of introducing a very small
inaccuracy in the computation.}
}
\value{
\code{betanmf} returns a list object with the following
elements:

\item{F}{A dense matrix containing estimates of the factors.}

\item{L}{A dense matrix containing estimates of the loadings.}

\item{progress}{A data frame containing more detailed information
  about the algorithm's progress. The data frame should have
  \code{numiter} rows. The columns of the data frame are: "iter", the
  iteration number; "loglik", the log-likelihood at the current
  factor and loading estimates; "dev", the deviance at the current
  factor and loading estimates; "delta.l", the largest change in the
  factors matrix; "delta.f", the largest change in the loadings
  matrix; and "timing", the elapsed time in seconds (based on
  \code{\link{system.time}}).}

An object capturing the initial state of the optimization
algorithm. It is a list with the following elements:

\item{F}{A matrix containing initial estimates of the factors.}

\item{L}{A matrix containing initial estimates of the loadings.}
}
\description{
This function decomposes the input matrix X = L*F' by
  nonnegative matrix factorization (NMF) based on the "divergence"
  criterion; equivalently, it optimizes the likelihood under a
  Poisson model of the count data, X. It runs a specified number of
  multiplicative updates (MU) or expectation maximization (EM)
  updates to fit the L and F matrices.

  Although the EM updates are mathematically equivalent to the
  multiplicative updates, and therefore they share the same
  convergence properties, the implementation of EM is quite
  different; in particular, the EM updates are more suitable for
  sparse counts matrices.
}
\details{
The multiplicative and EM updates are very simple and
  fast. However, they can also be very slow to converge to a
  stationary point of the objective, particularly when the data are
  sparse.

  This function is mainly for internal use, and should only
  be called directly if you really know what you are doing. In
  particular, only minimal argument checking is performed; if you are
  not careful, you will get poor results are errors that are
  difficult to interpret.

  The implementation of the multiplicative updates is adapted from
  the MATLAB code by Daichi Kitamura \url{http://d-kitamura.net}.

  The "safeguard" step preventing the factors and loadings from
  exactly reaching zero is motivated by Theorem 1 of Gillis & Glineur
  (2012).

  An additional re-scaling step is performed at each iteration to
  promote numerical stability.

  Since the multiplicative updates are implemented using standard
  matrix operations, the speed is heavily dependent on the
  BLAS/LAPACK numerical libraries used. In particular, using
  optimized implementations such as OpenBLAS or Intel MKL can result
  in much improved performance of the multiplcative updates.
}
\examples{

# Simulate a 100 x 200 data set.
suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
X <- simulate_count_data(100,200,3)$X

# Optimize a Poisson non-negative matrix factorization with k = 3
# topics by running 100 multiplicative updates.
F0   <- matrix(runif(600),200,3)
L0   <- matrix(runif(300),100,3)
fit1 <- betanmf(X,F0,L0,100,method = "mu")
fit2 <- betanmf(x,F0,L0.100,method = "em")

# Plot the improvement in the solution over time.
dev.min <- 19661.4155
with(fit$progress,
     plot(iter,dev - dev.min,type = "l",log = "y",
          xlab = "iteration",ylab = "distance to solution"))

}
\references{
Gillis, N. and Glineur, F. (2012). Accelerated multiplicative
  updates and hierarchical ALS algorithms for nonnegative matrix
  factorization. \emph{Neural Computation} \code{24}, 1085–1105. 

  Lee, D. D. and Seung, H. S. (2001). Algorithms for
  non-negative matrix factorization. In \emph{Advances in Neural
  Information Processing Systems} \bold{13}, 556–562.
}
\seealso{
\code{\link{pnmfem}}
}
