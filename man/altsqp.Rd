% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/altsqp.R
\name{altsqp}
\alias{altsqp}
\alias{altsqp_control_default}
\title{Alternating SQP Method for Optimizing Topic Models and
  Non-negative Matrix Factorizations}
\usage{
altsqp(X, fit, numiter = 100, version = c("Rcpp", "R"),
  control = list(), verbose = TRUE)

altsqp_control_default()
}
\arguments{
\item{X}{The n x m matrix of counts or pseudocounts. It can be a
dense matrix or sparse matrix.}

\item{fit}{A list containing two (dense, non-negative) matrices,
\code{fit$F} and \code{fit$L}; for example, this can be the output
of \code{altsqp}. The former is an m x k matrix of factors (or
"basic vectors"), and the latter is an n x k matrix of loadings (or
"activations"). For \code{loglik.multinom}, it is additionally
required that each row of \code{fit$L} and each column of
 \code{fit$F} must sum to 1; \code{poisson2multinom} can be used to
generate factors and loadings satisfying this requirement. For
\code{altsqp}, this provides the initial estimates.}

\item{numiter}{A positive integer specifying the number of
updates to perform.}

\item{version}{With \code{version = "R"}, a slower, but more easily
debugged, implementation is used; with \code{version = "Rcpp"}, a
faster, less easily debugged implementation is used.}

\item{control}{A list of parameters controlling the behaviour of
the optimization algorithm. See \sQuote{Details}.}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress
and a summary of the optimization settings are printed to the
console.}

\item{e}{A small, non-negative number that is added to the
terms inside the logarithms to sidestep computing logarithms of
zero. This prevents numerical problems at the cost of introducing a
small (and typically very small) inaccuracy in the computation.}
}
\value{
\code{altsqp} returns a list object with the following
elements:

\item{F}{A dense matrix containing estimates of the factors.}

\item{L}{A dense matrix containing estimates of the loadings.}

\item{value}{The value of the objective (or cost function) at the
  outputted values of \code{F} and \code{L}. The objective function
  is equal to \code{-loglik.poisson(X,out$,out$L)}, where \code{out}
  is the \code{altsqp} return value.}

\item{progress}{A data frame containing more detailed information
  about the algorithm's progress. The data frame should have
  \code{numiter} rows. The columns of the data frame are: "iter", the
  SQP iteration; "objective", the value of the objective at the
  current estimate of the solution; "max.diff", the maximum
  difference in the Poisson rate parameters \code{tcrossprod(L,F)}
  between two the successive iterations; "beta", the current setting
  of the extrapolation parameter (zero means no extrapolation is
  used); and "timing", the elapsed time in seconds (based on
  \code{\link{system.time}}).}

\code{poisson2multinom} returns an updated \code{fit}, in which the
factors \code{fit$F} and loadings \code{fit$L} are converted to
matrices of the same dimension containing, respectively, word
probabilities and topic probabilities.

\item{F}{A dense matrix containing estimates of the factors.}

\item{L}{A dense matrix containing estimates of the loadings.}

\code{loglik.poisson} and \code{loglik.multinom} return a single
numeric value giving the value of the log-likelihood.
}
\description{
Compute maximum-likelihood estimates for the Poisson
  topic model with factors F and loadings L; equivalently, find a
  non-negative matrix factorization \eqn{L * F^T} of matrix X that
  optimizes the "generalized Kullback-Leibler" (or Bregman)
  divergence objective.
}
\details{
Functions \code{loglik.poisson} and \code{loglik.multinom}
compute the log-likelihood for the Poisson and multinomial topic
models, excluding terms that do not depend on the model
parameters. These functions can be used to evaluate a solution
returned by \code{altsqp}.

Use function \code{poisson2multinom} to obtain parameters for the
multinomial topic model from the Poisson topic model.

The \code{control} argument to \code{altsqp} is a list in which any
of the following named components will override the default
optimization algorithm settings (as they are defined by
\code{altsqp_control_default}):

\describe{

\item{\code{nc}}{When \code{version = "Rcpp"}, this setting
  determines the \code{numThreads} argument in the call to
  \code{\link[RcppParallel]{setThreadOptions}}. When \code{version =
  "R"}, this setting determines the \code{mc.cores} argument in calls
  to \code{\link[parallel]{mclapply}}.}

\item{\code{numem}}{A non-negative number specifying the number of
  EM (\emph{i.e.}, multiplicative) updates to run at each outer loop
  iteration.}

\item{\code{numsqp}}{A non-negative number specifying the number of
  SQP updates to run at each outer loop iteration.}

\item{\code{extrapolate}}{The iteration at which extrapolation is
  initiated. If \code{extrapolate > numiter}, extrapolation is not
  used.}

\item{\code{beta.init}}{The initial setting of the extrapolation
  parameter.}

\item{\code{beta.increase}}{The extrapolation parameter is
  increased by this amount whenever the update improves the
  solution. This is denoted by \eqn{\gamma} in Algorithm 3 of Ang &
  Gillis (2019).}

\item{\code{beta.reduce}}{The extrapolation parameter is decreased
  by this amount whenever the update does not improve the solution.
  This is denoted by \eqn{\eta} in Algorithm 3 of Ang &
  Gillis (2019).}

\item{\code{betamax.increase}}{The upper bound on the extrapolation
  parameter is increased by this amount whenever the update improves
  the solution. This is denoted by \eqn{\bar{\gamma}} in Algorithm 3
  of Ang & Gillis (2019).}

\item{\code{tol}}{A small, non-negative number specifying the
  convergence tolerance for the active-set step. Smaller values will
  result in higher quality search directions for the SQP algorithm
  but possibly a greater per-iteration computational cost.}

\item{\code{zero.threshold}}{A small, non-negative number used to
  determine the "active set"; that is, it determines which entries of
  the solution are exactly zero. Any entries that are less than or
  equal to \code{zero.threshold} are considered to be exactly
  zero. Larger values of \code{zero.threshold} may lead to speedups
  for matrices with many columns, at the (slight) risk of prematurely
  zeroing some co-ordinates.}

\item{\code{zero.searchdir}}{A small, non-negative number used to
  determine when the search direction in the active-set step is
  considered "small enough".}

\item{\code{suffdecr}}{This parameter determines how stringent the
  "sufficient decrease" condition is for accepting a step size in the
  backtracking line search. Larger values will make the condition
  more stringent. This should be a positive number less than 1.}

\item{\code{stepsizereduce}}{The multiplicative factor for
  decreasing the step size in the backtracking line search.}

\item{\code{minstepsize}}{The smallest step size accepted by the
  line search step. Should be a number greater than 0 and at most 1.}

\item{\code{e}}{The same as input argument \code{e} described above.}
}
}
\examples{

library(Matrix)
library(NNLM)

# Generate a 300 x 400 data matrix to factorize. Less than 10\% of the
# matrix elements should be nonzero.
set.seed(1)
n <- 300
m <- 400
k <- 3
F <- matrix(runif(m*k)/3,m,k)
L <- matrix(runif(n*k)/3,n,k)
X <- matrix(rpois(n*m,tcrossprod(L,F)),n,m)
X <- as(X,"dgCMatrix")
nnzero(X)/(n*m)

# Generate random initial estimates of the factors and loadings.
fit0 <- list(F = matrix(runif(m*k),m,k),
             L = matrix(runif(n*k),n,k))

# Run 100 iterations of the sequential coordinate-wise descent
# algorithm implemented in the NNLM package. Note that nnmf does not
# accept a sparse matrix as input, so we need to provide it with a
# dense matrix instead.
fit1 <- suppressWarnings(
  nnmf(as.matrix(X),k,init = list(W = fit0$L,H = t(fit0$F)),
       method = "scd",loss = "mkl",max.iter = 100,rel.tol = 0, 
       inner.max.iter = 4,trace = 1,verbose = 0))

# Run 100 coordinate-wise updates of the SQP method implemented in
# the fastTopics package.
fit2 <- altsqp(X,fit0,verbose = FALSE)

# Compare the Poisson log-likelihood at the two solutions; the
# likelihood should be higher at the the altsqp solution.
fit1$F <- t(fit1$H)
fit1$L <- fit1$W
print(loglik.poisson(X,fit1),digits = 14)
print(loglik.poisson(X,fit2),digits = 14)

# Compare the multinomial log-likelihood at the two solutions; again,
# the likelihood should be higher at the altsqp solution.
print(loglik.multinom(X,poisson2multinom(fit1)),digits = 14)
print(loglik.multinom(X,poisson2multinom(fit2)),digits = 14)

# Plot the improvement in the solution over time; the altsqp iterates
# (the solid, orange line) gets much closer to the best solution.
fbest    <- 31041.93896745
fit1$mkl <- n*m*fit1$mkl + sum(X - X*log(X + 1e-16))
plot(fit2$progress$iter,fit2$progress$objective - fbest,
     log = "y",col = "darkorange",type = "l",lwd = 2,xlab = "iteration",
     ylab = "distance from solution")
lines(1:60,fit1$mkl - fbest,col = "darkblue",lwd = 2,lty = "dashed")

}
\references{
A. Ang and N. Gillis (2019). Accelerating nonnegative matrix
factorization algorithms using extrapolation. \emph{Neural Computation}
\bold{31}, 417-â€“439. \url{https://doi.org/10.1162/neco_a_01157}
}
