% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/altsqp.R, R/loglik.R, R/poisson2multinom.R
\name{altsqp}
\alias{altsqp}
\alias{altsqp_control_default}
\alias{loglik.poisson}
\alias{loglik.multinom}
\alias{poisson2multinom}
\title{Alternating SQP Method for Optimizing Topic Models and Non-negative Matrix Factorizations}
\usage{
altsqp(X, fit, numiter = 100, control = list(), verbose = TRUE)

altsqp_control_default()

loglik.poisson(X, fit, e = 1e-15)

loglik.multinom(X, fit, e = 1e-15)

poisson2multinom(fit)
}
\arguments{
\item{X}{The n x m matrix of counts or pseudocounts. It can be a
dense matrix or sparse matrix.}

\item{fit}{A list containing two (dense, non-negative) matrices,
\code{fit$F} and \code{fit$L}; for example, this can be the output
of \code{altsqp}. The former is an m x k matrix of factors (or
"basic vectors"), and the latter is an n x k matrix of loadings (or
"activations"). For \code{loglik.multinom}, it is additionally
required that each row of \code{fit$L} and each column of
 \code{fit$F} must sum to 1; \code{poisson2multinom} can be used to
generate factors and loadings satisfying this requirement. For
\code{altsqp}, this provides the initial estimates.}

\item{numiter}{A positive integer specifying the number of
updates to perform.}

\item{control}{A list of parameters controlling the behaviour of
the optimization algorithm. See \sQuote{Details}.}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress
and a summary of the optimization settings are printed to the
console.}

\item{e}{A small, non-negative number that is added to the
terms inside the logarithms to sidestep computing logarithms of
zero. This prevents numerical problems at the cost of introducing a
small inaccuracy in the computation.}
}
\value{
A list object with the following elements:

\item{F}{Describe F here.}

\item{L}{Describe L here.}

\item{value}{Describe "value" here.}

\item{progress}{Describe "progress" here.}
}
\description{
Compute maximum-likelihood estimates for the Poisson
  topic model with factors F and loadings L; equivalently, find a
  non-negative matrix factorization \eqn{L * F^T} of matrix X that
  optimizes the beta (or Bregman) divergence objective.
}
\details{
Functions \code{loglik.poisson} and \code{loglik.multinom}
compute the log-likelihood for the Poisson and multinomial topic
models, excluding terms that do not depend on the model
parameters. These functions can be used to evaluate a solution
returned by \code{altsqp}.

Use function \code{poisson2multinom} to obtain parameters for the
multinomial topic model from the Poisson topic model.

The \code{control} argument to \code{altsqp} is a list in which any
of the following named components will override the default
optimization algorithm settings (as they are defined by
\code{altsqp_control_default}):

\describe{

\item{\code{nc}}{Describe nc here.}

\item{\code{extrapolate}}{Describe extrapolate here.}

\item{\code{beta0}}{Describe beta0 here.}

\item{\code{betamaxinc}}{Describe betamaxinc here.}

\item{\code{betainc}}{Describe betainc here.}

\item{\code{betared}}{Describe betared here.}
}
}
\examples{

library(Matrix)
library(NNLM)

# Generate a 300 x 400 data matrix to factorize. Less than 10\% of the
# matrix elements should be nonzero.
set.seed(1)
n <- 300
m <- 400
k <- 3
F <- matrix(runif(m*k)/3,m,k)
L <- matrix(runif(n*k)/3,n,k)
X <- matrix(rpois(n*m,L \%*\% t(F)),n,m)
X <- as(X,"sparseMatrix")
nnzero(X)/(n*m)

# Generate random initial estimates of the factors and loadings.
fit0 <- list(F = matrix(runif(m*k),m,k),
             L = matrix(runif(n*k),n,k))

# Run 60 iterations of the sequential coordinate-wise descent
# algorithm implemented in the NNLM package. Note that nnmf does not
# accept a sparse matrix as input, so we need to provide it with a
# dense matrix instead.
fit1 <- suppressWarnings(
  nnmf(as.matrix(X),k,init = list(W = fit0$L,H = t(fit0$F)),
       method = "scd",loss = "mkl",max.iter = 60,rel.tol = 0, 
       inner.max.iter = 4,trace = 1,verbose = 0))

# Run 60 coordinate-wise updates of the SQP method implemented in the
# fastTopics package.
fit2 <- altsqp(X,fit0,numiter = 60,verbose = FALSE)

# Compare the Poisson log-likelihood at the two solutions; the
# likelihood should be higher at the the altsqp solution.
fit1$F <- t(fit1$H)
fit1$L <- fit1$W
print(loglik.poisson(X,fit1),digits = 14)
print(loglik.poisson(X,fit2),digits = 14)

# Compare the multinomial log-likelihood at the two solutions; again,
# the likelihood should be higher at the altsqp solution.
print(loglik.multinom(X,poisson2multinom(fit1)),digits = 14)
print(loglik.multinom(X,poisson2multinom(fit2)),digits = 14)

# Plot the improvement in the solution over time; the altsqp iterates
# (the solid, orange line) gets much closer to the best solution.
fbest    <- 31041.93896745
fit1$mkl <- n*m*fit1$mkl + sum(X - X*log(X + 1e-16))
plot(fit2$progress$iter,fit2$progress$objective - fbest,
     log = "y",col = "darkorange",type = "l",lwd = 2,xlab = "iteration",
     ylab = "distance from solution")
lines(1:60,fit1$mkl - fbest,col = "darkblue",lwd = 2,lty = "dashed")

}
\references{
A. Ang and N. Gillis (2019). Accelerating nonnegative matrix
factorization algorithms using extrapolation. \emph{Neural Computation}
\bold{31}, 417-â€“439. \url{https://doi.org/10.1162/neco_a_01157}
}
