% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/betanmf.R
\name{betanmf}
\alias{betanmf}
\title{Multiplicative Update Rules for Non-negative Matrix Factorization}
\usage{
betanmf(X, F0, L0, numiter = 1000, lowerbound = 1e-15, e = 1e-15,
  verbose = TRUE)
}
\arguments{
\item{X}{The n x m matrix of counts; all entries of X should be
non-negative. In particular, sparse matrices are not accommodated
in this implementation; \code{is.matrix(X)} must give \code{TRUE},
otherwise an error will be thrown.}

\item{F0}{This is the initial estimate of the factors (also called
"basis vectors"). It should be an m x k matrix, where m is the
 number of columns of X, and k > 1 is the rank of the matrix
 factorization, or the number of topics. All entries of F should be
 non-negative.}

\item{L0}{This is the initial estimate of the loadings (also called
"activations"). It should an n x k matrix, where n is the number of
rows of X, and k > 1 is the rank of the matrix factorization. All
entries of L should be non-negative.}

\item{numiter}{The number of multiplicative updates to run.}

\item{lowerbound}{A small positive constant used to safeguard the
multiplicative updates. The multiplicative updates are implemented
as \code{F <- pmax(F1,lowerbound)} and \code{L <- pmax(L1,lowerbound)},
where \code{F1} and \code{L1} are the factors and loadings
matrices obtained by applying a single multiplicative update
rule. Setting \code{lowerbound = 0} is allowed, but the
multiplicative updates are not guaranteed to converge to a
stationary point without this safeguard, and a warning will be
given in this case.}

\item{e}{A small, non-negative number added to the terms inside the
logarithms to avoid computing logarithms of zero. This prevents
numerical problems at the cost of introducing a very small
inaccuracy in the computation.}

\item{verbose}{When \code{verbose = TRUE}, information about the
algorithm's progress is printed to the console at every iteration.}
}
\value{
A list containing updated estimates of the factors, F, and
  loadings, L.
}
\description{
This function decomposes the input matrix X = L*F' by
  nonnegative matrix factorization (NMF) based on the "divergence"
  criterion; equivalently, it optimizes the likelihood under a
  Poisson model of the count data, X. It runs a specified number of
  multiplicative updates (MU) to fit the L and F matrices. Note that
  the multiplicative updates can also be derived, and hence
  interpreted, as an expectation maximization (EM) algorithm.
}
\details{
The multiplicative updates are very simple and
  fast. However, they can also be very slow to converge to a
  stationary point of the objective, particularly when the data are
  sparse.

  This function is mainly for internal use, and should only
  be called directly if you really know what you are doing. In
  particular, only minimal argument checking is performed; if you are
  not careful, you will get poor results are errors that are
  difficult to interpret.

  This implementation is adapted from the MATLAB code by Daichi
  Kitamura \url{http://d-kitamura.net}.
}
\examples{

# Simulate a 100 x 200 data set.
set.seed(1)
X <- simulate_count_data(100,200,3)$X

# Fit a Poisson topic model with k = 3 topics by running 100
# multiplicative updates.
F0  <- matrix(runif(600),200,3)
L0  <- matrix(runif(300),100,3)
fit <- betanmf(X,F0,L0,100)

# Plot the improvement in the solution over time.
dev.min <- 19661.4155
with(fit$progress,
     plot(iter,dev - dev.min,type = "l",log = "y",
          xlab = "iteration",ylab = "distance to solution"))

}
\references{
Gillis, N. and Glineur, F. (2012). Accelerated multiplicative
  updates and hierarchical ALS algorithms for nonnegative matrix
  factorization. \emph{Neural Computation} \code{24}, 1085–1105. 

  Lee, D. D. and Seung, H. S. (2001). Algorithms for
  non-negative matrix factorization. In \emph{Advances in Neural
  Information Processing Systems} \bold{13}, 556–562.
}
\seealso{
fit_topics
}
